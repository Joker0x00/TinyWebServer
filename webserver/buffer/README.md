# Buffer

为了高效便捷的实现数据的存取，我们自定义了一个缓冲区数据结构，其主要功能是实现数据的读取、写入和空间自增。下图是缓冲区的结构图，我们使用`vector<char>`作为最基本的数据结构，实现了一个队列结构的缓冲区，并定义了三个指针，分别是头指针、读指针和写指针（这里的指针都使用下标代替，并非真正的指针）。

![](https://secure2.wostatic.cn/static/4S7visPdx4g798wZb9Rufv/image.png?auth_key=1721658093-ns6muZo9XBGpseJvczXCeu-0-148ac1b547e58537efdbda054f212faa)

## 1 向Buffer写入数据

写指针被初始化为0，指向`vector`的首元素。写入数据时，需要提供待写入字符串的首地址和长度。待写入字符串被拷贝到写指针指向的位置，此时可能会出现空间不够的情况。

- 待写入数据长度**小于等于**预留区域和空闲区域长度之和：

  将数据区域搬运到头指针指向的位置，并更新读指针和写指针
- 待写入数据长度**大于**预留区域和空闲区域长度之和：

  利用`vector的`动态扩容机制，增大缓冲区长度。

## 2 从Buffer读取数据

读指针被初始化为0，从读指针开始读取字符串，直到写指针为止。

## 3 动态扩容

当预留区域和空闲区域加在一起也不够写下新的数据时，需要对缓冲区进行扩容。`vector.resize()`函数将被调用，从而实现了扩充容量。

## 4 从socket中读取数据

由于从socket读取的数据长度未知，直接向buffer中写入的数据的长度可能会超过`vector`的最大容量而引发错误，而增大`buffer`的初始容量又会浪费资源。因此，可以借用一个大容量的栈区作为缓冲。`buffer`和栈区同时接收数据，之后再将栈区中的数据写入`buffer`中，这样便可巧妙地解决问题。